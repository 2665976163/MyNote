# 注解

​	类似于标签，比如常见的注解@Overide当一个方法被该注解标记后就代表该方法为重写方法.

## 内置元注解

元注解就是注解上的注解，我们自定义注解是用于解释用户定义好的数据的(如：类，方法，字段等)，而元注解就是用于解释我们的自定义注解，当别人使用自定义注解时应该怎么怎么样.

### 元注解

@Retention、@Documented、@Target、@Inherited、@Repeatable

主要用于注解自定义注解（我们使用的都是为自定义注解）.

#### 1. @Retention()

```java
当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。
```

**Retention源码**

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
    /**
     * Returns the retention policy.
     * @return the retention policy
     */
    RetentionPolicy value();
}
```

解析：

​	该**Retention**认真说的话也**是一个自定义注解**，该注解上使用了三个注解(Doc..Target..还有一个它自己)

它自己给自己注解，并传入了RetentionPolicy枚举中的RUNTIME对象，**这个枚举为该类的核心**，RetentionPolicy枚举类中一共定义了三个对象，也可以说是该枚举的属性，SOURCE、CLASS、RUNTIME。

**RetentionPolicy：**

​	**SOURCE**：表示该注解只在编译期有作用，但在运行期则被抛弃. class中也不会存在该注解的声明.

​	**CLASS**：表示该注解在 编译期 与 .class文件 中会存在，但jvm不会分配内存(运行期中不存在).

​	**RUNTIME**：表示该注解在编译期 与 运行期 .class 文件 中都会存在

若传入以上没有分配到内存的字段，反射将无法获取，因为反射是在运行期获取Class对象的。



**位置**：看target传入的内容，代表只能在注解上注解，详情参考 [3. Target]















#### 2. @Documented()

```java
当需要到处doc文档需要显示类或其他中的注解时，则可以使用该注解
```

**Documented源码**

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Documented {
}
```

解析：

​	该Documented注解没有任何内容，但做doc文档时读取到数据中许多注解中有包含该注解时，那么就会将该数据中的所有注解明确标明在doc文档中.

​	该 documented 也是可以在内存中获取的。



**位置：**看target 传入的内容，表示只能在注解上注解.































#### 3. @Target()

```java
该注解用于规定被它注解过的注解只能在某些地方使用，比如类上 || 方法上 || 字段等.
```

@Target源码

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    /**
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * @return an array of the kinds of elements an annotation type
     * can be applied to
     */
    ElementType[] value();
}
```

该注解中定义了一个字段数组，可以存放ElementType的属性

> ElementType 中的枚举对象

```java
ElementType.ANNOTATION_TYPE 可以给一个注解进行注解.
ElementType.CONSTRUCTOR 可以给构造方法进行注解.
ElementType.FIELD 可以给属性进行注解.
ElementType.LOCAL_VARIABLE 可以给局部变量进行注解.
ElementType.METHOD 可以给方法进行注解.
ElementType.PACKAGE 可以给一个包进行注解.
ElementType.PARAMETER 可以给一个方法内的参数进行注解.
ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举.
```

了解完这些枚举对象之后

​	这个@Target内置注解也就不那么神秘了，主要功能就是标明当前自定义注解可以在哪些地方使用。

> 使用格式

```java
@Target(value={ElementType.METHOD,ElementType.TYPE})
public @inteface MyAnnotation{ //自定义注解
    String value default "默认值";
}
```



















#### 4. @Inherited()

```java
Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。
```

@Inherited 的源码

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Inherited {}
```

> 使用格式

```java
@Documented	//标明若该自定义注解在其他超类中若标记，子类若没有注解则可以继承过来
public @inteface MyAnnotation{ //自定义注解
    String value default "默认值";
}
```

注意反射的获取Annotation的方式，以免获取到父类的还以为继承过来了.

getAnnotations() ：获取本类public 父类public的注解

getDeclaredAnnotations() ：获取本类声明的所有注解











#### 5. @Repeatable()

```java
	1.8出现的，当一个自定义注解上出现该内置注解，那该自定义注解可以在一个目标中注解多次，此目标可以是类，接口，方法等，没有被该注解注解过则只能默认注解一次.
     1. 使用想Repeatable注解 自定义注解 首先必须传入 存储注解的容器 class对象.
     2. 自定义注解 上除了Repeatable注解之外若有其他注解那么 注解容器. 必须也有(Inherited除外)
     3. 注解容器中有的注解 自定义容器可以没有，因为自定义注解可以拿过来用.
```

> 使用格式

```java
@Repeatable(persons.class)	//传入存储注解容器class对象
public @inteface person{	//自定义注解
    String value default "默认值";
}
@inteface persons{	//存储注解容器
    person[] value default {"默认值1","默认值2"};
}
```











#### 为什么元注解要注解自己呢？

仅供参考，可能也有一些推敲错误.

原本是一些属性起到主要作用，jvm读取时会内部处理这些属性的含义，但若是这些属性定义在类上或其他之上则不规范，不是同一格式，再者说若是一些枚举或者变量定义在类上或其他之上又怎能区分到底是变量还是注解呢？因此注解类型诞生了，自定义注解中可以传入数据，注解以@开头，统一了格式，让人一见到某数据之上的@xxx就明白是注解，当运行时jvm开始读取这个自定义注解，主要还是读取该注解中的属性做相应的事情，这就是为什么内置注解有些要注解自己的原因。同一格式，区分字段。









#### 创建自定义注解

1. 创建自定义注解
2. 标明可以在方法，类型中使用，标明可以在jvm中可见

```java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RententionPoliy.RUNTIME)
public @interface Test_sss{
    	//@interface 代表注解关键字，而并非接口
}
```

#### 自定义注解属性

注解中只能用基本类型，Class，Enum，注解类型，String，和它们的数组类型，不允许其他类型.

```java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RententionPoliy.RUNTIME)
public @interface Test_sss{
    String value(); //注解中的字段后面必须加上() 
}
```

若该注解中的字段仅一个且名为value那么传值则不需要字段名=value，而可以直接value

```java
//自定义注解中是value，则可以直接"123",它会默认放入value中，也可以 value = "123";
@Test_sss("123")   //不同之处
class Main{}
//===============
@Test_sss(value="123")
class Main{}
```

若不是value 则必须这样

```java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RententionPoliy.RUNTIME)
public @interface Test_sss{
    String sss();
}
@Test_sss(sss = "123") //不同之处
class Main{}
```

若一个注解中有多个值，且中有value，传参时也是必须写上 value=值 的

```java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RententionPoliy.RUNTIME)
public @interface Test_sss{
    String sss();
    String value();
}
@Test_sss(sss = "123",value="234") //不同之处
class Main{}
```

若注解内的字段有默认值则使用该注解就可以不传入该有默认值的参数.

```java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RententionPoliy.RUNTIME)
public @interface Test_sss{
    String sss() default "222";
    String value();
}
@Test_sss(value="234") //使用时sss没有传入参数，则使用默认值
class Main{}
```

总结：

   	1. 字段必须带 () 括号
   	2. 注解中若只有一个参数且是value的则传参时则不需要写参数名
   	3. 参数赋值 参数名=参数值  若为数组: value = {123,234,345}
   	4. 若字段加上默认值则使用该注解时可以不写该有默认值的字段
   	5. 字段括号后方空格 default "对应的数据类型值" 就可以设置默认值了

