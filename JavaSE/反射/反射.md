#### 反射

> 概念

```java
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.
```

> 总结

```java
反射就是把java类中的各种成分映射成一个个的Java对象
例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。
     （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）
如图是类的正常加载过程：反射的原理在与class对象。
熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。

Class    用于描述类本身（.class文件）
Package	 用于描述类所属的包.
Field	 用于描述类中的属性.
Method	 用于描述类中的方法.
Construtor	用于描述构造方法.
Annotation	用于描述类中的注解.
    
```

> 一句话

```java
反射就是将.class文件映射成一个Class对象，可以使用.class中所有已经声明了的字段或方法.
```

##### 类的操作（Class）

>  获取Class的三种方式

```java
Class clazz = Class.forName("包名.类名");
Class clazz = 类名.class;
Class clazz = 对象引用.getClass();
```

> 通过获取到的Class对象获取包名

```java
Package pack = clazz.getPackage();
```

> 返回该类的名称

```java
//只有类名，无包名
String className = clazz.getSimpleName();
//有类名，有包名
String className = clazz.getName();
```

> 通过获取到的Class对象获取修饰符

```java
int right = clazz.getModifiers();
```

```java
对应的修饰符：
0 --> defualt  1 --> public  2 --> private  4 --> protected  8 --> static
16 --> final  32 --> synchronized  64 --> volatile  128 --> transient	
256 --> native  512 --> interface  1024 --> abstract 
```

> 通过获取到的Class对象创建该类对象

```java
Person per1 = clazz.newInstance();  //调用的是无参构造
```

> 通过获取到的Class对象获取该类的父类对象 || 接口

```java
//获取当前类的父类
Class father = clazz.getSuperClass();
//获取当前类的父接口
Class[] father = clazz.getIntfaces();
```

> 获取类中的（公有）内部类

```java
Class[] sss = clazz.getClasses();
```

##### 属性的操作（Field）

> 通过获取到的Class对象获取(公有的)属性(子类如果私有该属性，就找父类的,或接口等)

```java
//获取该类或父类的该属性
Field fie = clazz.getField("属性名");
//获取该类的类型
Class type = fie.getType();
//返回类型是Object 可以 强转为对应类型
Object sss = fie.get("对象名");	
//获取该类且父类所有属性
Field[] fie = clazz.getFields();
//也可以修改获取到得公有属性.
fie.set("对象名,新内容");
//也可以通过以上的办法获取到属性的修饰符.
in fies = fie.getModifiers();
```

> 通过获取到的Class对象获取(任何修饰符修饰的)属性(不能访问父类的,只能找该对象本身的)

```java
Field fie = clazz.getDeclaredField("属性名");
//true的值表示反射对象应该在使用时抑制Java语言访问检查
fie.setAccessible(true);	//true 不会执行java语言检查   false 强制执行
//false的值表示反映的对象应该强制执行Java语言访问检查
fie.get("对象名");
fie.set("对象名","新内容");
也可以获取该类所有属性
//获取该类的所有属性
Field[] fie = clazz.getDeclaredFields();
```

##### 方法的操作（method）

> 通过获取到的Class对象获取(公有的)方法(子类如果私有该属性，就找父类的,或接口等)

```java
Method method = clazz.getMethod("方法名");
//运行方法
method.invoke("哪个对象的这个方法","方法参数，如果没有可以不填");
//获取方法的修饰符
method.getModifiers();
//获取参数列表类型
method.getParameterTypes();
```

> 通过获取到的Class对象获取(任何修饰符修饰的)方法(不能访问父类的,只能找该对象本身的)

```java
Method method = clazz.getDeclaredMethod("方法名");
//抑制Java语言访问检查
method.setAccessible(true);  //true 不会执行java语言检查   false 强制执行
//运行方法
method.invoke("哪个对象的这个方法","方法参数，如果没有可以不填");
//获取方法的修饰符
method.getModifiers();
//获取参数列表类型
method.getParameterTypes();
```

> 构造方法操作

```java
平常只能通过newInstance()方法创建一个空构造的对象，若该类不存在空构造则创建不了
```

> 举例

```java
对象类型 tempModel = clazz.newInstance(); 若该类不存在空构造则抛出异常 
```

> 构造方法我们自己决定用哪个创建对象

```java
//参数类型的class
Constructor constructor = clazz.getDeclaredConstructor(new Class[]{String.class,Integer.class});
//与上对应创建对象
对象类型 tempModel = (对象类型)constructor.newInstance("123",123);//"参数与上面对应"

//获取构造方法的参数
Class[] typeClass = constructor.getParameterTypes();
```

```java
//有些需要强转的地方我没有强转注意哦.
//一些同样的方法我就没有写了，都是通用的,如获取修饰符，方法形参等，想了解请查api.
```









> 小案例

```java
public class Main {
    public static void main(String[] args) throws Exception {
        test_1().invoke();
    }

    public static Parent test_1() throws Exception{
        //test.txt文件路径
        String path = "";
        Properties properties = new Properties();
        properties.load(new FileInputStream(path));
        String classPath = properties.getProperty("classPath");
        Parent bean = (Parent) Class.forName(classPath).getConstructor().newInstance();
        return bean;
    }
}
//无论配置文件更新到什么版本，我都可以通过配置文件读取最新版本，因为他们都是parent的子类
```

> 所有版本规范

```java
public interface Parent {
    void invoke();
}
```

> 老版本

```java
public class ParentImpl_1 implements Parent{
    @Override
    public void invoke() {
        System.out.println("传说皮肤 老版本");
    }
}


```

> 新版本

```java
public class ParentImpl_2 implements Parent {
    @Override
    public void invoke() {
        System.out.println("传说开启星元功能... (新版本)");
    }
}
```

```java

小案例：
找我有事请大叫 2019/8/9 星期五 19:24:55
开始读取配置文件拿出类路径[这在当前算是新模块但到以后就会慢慢成为老模块]
，若以后有新的模块则将该配置文件改一下就可以了

找我有事请大叫 2019/8/9 星期五 19:25:04
原代码不需要改变

找我有事请大叫 2019/8/9 星期五 19:25:19
俩个类都实现一个接口

找我有事请大叫 2019/8/9 星期五 19:25:39
俩个类是不同模块

找我有事请大叫 2019/8/9 星期五 19:25:54
反射读取类路径，创建对象只需要强转为父类就行了
```

