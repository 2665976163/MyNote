# 泛型

泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为[泛型类](https://baike.baidu.com/item/%E6%B3%9B%E5%9E%8B%E7%B1%BB/9038353)、泛型接口、泛型方法。 [Java语言](https://baike.baidu.com/item/Java%E8%AF%AD%E8%A8%80)引入泛型的好处是安全简单。

在Java SE 1.5之前，没有泛型的[情况](https://baike.baidu.com/item/%E6%83%85%E5%86%B5/1392364)的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的[强制类型转换](https://baike.baidu.com/item/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/1580197)，而这种转换是要求开发者对[实际参数](https://baike.baidu.com/item/%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0/2231530)类型可以预知的情况下进行的。对于强制类型转换错误的情况，[编译器](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067)可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。

泛型的好处是在编译的时候检查[类型安全](https://baike.baidu.com/item/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/7308285)，并且所有的[强制转换](https://baike.baidu.com/item/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/4463315)都是自动和[隐式](https://baike.baidu.com/item/%E9%9A%90%E5%BC%8F/957024)的，以提高代码的重用率。



编译之后，程序会采取去泛型化的措施，也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 



> 作用

在编译期间检测类型是否正确，常用于集合、类

### 泛型类

> 定义泛型类

```java
class Test<E>{
    private E value;
    public E getValue(){
        return value;
    }
}
```

### 泛型方法

> 定义泛型方法

```java
class Test<E>{
    private E value;
    public <A> A getValue(A a,B b){
        return a;
    }
}
```

若传入的值为 String,Integer 双方不一致则A就为Object类型，若一直则会是对应类型



> <?>	通配符

在泛型中所有类型都是平等的，比如Object 与 String 就是平等的，不存在父类类型指向子类实例

> 举例

```java
public static void main(String[] args){
    ArrayList<String> list1 = new ArrayList();
    ArrayList<Object> list2 = list1;	//会报错
}
```

以上会报错，因为类型不匹配，都是平等的，而这时就需要 ? 通配符了

```java
public static void main(String[] args){
    ArrayList<String> list1 = new ArrayList();
    ArrayList<?> list2 = list1;
}
```

这样就成功了，但是还隐藏了一些问题，？代表未知类型，现在list2 指向 list1 的引用，但list2声明的泛型为未知类型，那么若进行添加时就不清楚到底能存放什么类型了，所以只能使用list1 之前添加过的值，list2 并不能进行添加

> 解决方法

```java
public static void main(String[] args){
    ArrayList<String> list1 = new ArrayList();
    ArrayList<? extends String> list2 = list1;
}
```

这样写就代表若进行添加要么就是String ，要么就是String的子类

> 也有另外的一种方式

```java
public static void main(String[] args){
    ArrayList<String> list1 = new ArrayList();
    ArrayList<? super String> list2 = list1;
}
```

这样代表要么是String 要么就是String 的父类

以上俩种若传入的并非String则产生了一个向上转型的过程（子类实例指向父类类型）



> <? extends E>  || <? super E>

这俩种方式只能让类型相同的不同泛型的赋值

```java
ArrayList<String> list1 = new ArrayList();
ArrayList<? super String> list2 = list1;
```

> 若不同类型的则不行

```javascript
HashSet<String> set = new HashSet();
ArrayList<? super String> = set; //报错
```

就像以上那样



### 泛型接口

> 泛型接口

```java
interface User<E>{
    void show(E e);
}
```

> 实现场景一

```java
class UserImpl implements User<String>{
    @Overide
    public void show(String e){	//父类方法接收类型将依据实现给的类型转为相应类型
        
    }
}
```

> 实现场景二

```java
class UserImpl<E> implements User<E>{
    @Overide
    public void show(E e){	//子类被实例为什么类型父类与其一致
        
    }
}
```

> 实现场景三

```java
class UserImpl implements User{
    @Overide
    public void show(Object e){	//若子类不指定则默认为Object类型
        
    }
}
```

