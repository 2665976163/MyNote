## 多线程的概念

```java
	1995年，在java诞生之初，诸如james Gosling等java主要设计者,就非常明智地选择让JAVA内置支持"多线程",
这使得 Java 相比于同一时期的其他编程语言，有着非常明显的优势.
    线程是操作系统任务调度的最小单位。多线程可以让更多任务并发执行，从而让程序的运行性能显著提升，特别是在多核（muti-core）或众核（mangy-core）环境下，表现的就更加抢眼.
```

```java
 注意：进程管理着多个线程,线程会将进程获得的资源分配,在多线程IOS中，进程不是一个可执行的实体.
    通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。 在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，  而把线程作为独立运行和独立调度的基本单位。 由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，  能更高效的提高系统内多个程序间并发执行的程度，从而显著提高系统资源的利用率和吞吐量。
```

#### 线程的创建

##### 1.创建线程方式一

> 创建线程方式一

```java
1.创建：继承Thread + 重写run方法 
2.启动：创建子类对象 + 调用start方法
```

> 举例

```java
public class Main{
    public static void main(String args[]){
        StartThread mode = new StartThread();
        mode.start();
        for(int i=0;i<10;i++){
            System.out.println("吃饭不如跳舞");
        }
    }
}
class StartThread extends Thread{
    public void run(){
        for(int i=0;i<10;i++){
            System.out.println("一边吃饭");
        }
    }
}
```

##### 2.创建线程方式二

> 创建线程方式二

```java
1.创建:实现Runnable + 重写run方法
2.启动：创建实现对象 + 通过Thread调用start方法
格式：new Thread(实现对象).start方法
```

> 举例

```java
public class Main{
    public static void main(String args[]){
        new Thread(new StartThread()).start();
        for(int i=0;i<10;i++){
            System.out.println("吃饭不如跳舞");
        }
    }
}
class StartThread implements Runnable{
    public void run(){
        for(int i=0;i<10;i++){
            System.out.println("一边吃饭");
        }
    }
}
```

```java
推荐：第二种方式，因为java中只支持单一继承的局限性，所以不推荐第一种
```

##### 3.创建线程方式三

> 创建线程方式三

```java
不常用，有时间深入了解
call相比run方法支持抛出异常，功能可能更强.
    
1.创建：实现Callable接口，重写call方法
2.启动：创建实现类对象
		创建执行服务：	ExecutorService 变量名(s) = Executors.newFixedThreadPool(提交个数);
		提交执行：Future<Boolean> 变量名(w) = s.submit(实现类对象);
		获取结果：boolean 变量名 = w.get(); //get方法需要抛出俩个异常 可以不需要结果
         关闭服务：s.shutdownNow();	//释放资源
		
```

> 举例

```java
import java.util.concurrent.*;
public class Main{
    public static void main(String args[])throws Exception{
        StartThread model = new StartThread();
        StartThread model1 = new StartThread();
        ExecutorService s = Executors.newFixedThreadPool(2);
        Future<Boolean> w = s.submit(model); //提交一个可运行的任务执行
        Future<Boolean> ws = s.submit(model1);	//提交一个可运行的任务执行
        s.shutdownNow();	//尝试关闭自启动的线程
        for(int i=0;i<100000;i++){
            System.out.println("吃饭不如跳舞");
        }
    }
}
class StartThread implements Callable<Boolean>{
    public Boolean call(){
        for(int i=0;i<100000;i++){
            System.out.println("一边吃饭");
        }
        return true;
    }
}
```



> 小测试：龟兔赛跑

```java
public class Main{
    public static void main(String[] args){
        new Thread(new startThread(),"乌龟").start();
    }
}
class startThread implements Runnable{
    private static String fristName;
    public void run(){
        for(int i=1;i<100;i++){
            System.out.println(Thread.currentThread().getName()+"====>"+i);
            count(i);
        }
    }
    public static void count(int i){
        if(fristName!=null){
            return true;
        }else if(i == 100){
            fristName = Thread.currentThread().getName();
        }
    }
}
```

> 小测试：静态代理模式

```java
public class Main{
    public static void main(String[] args){
        new Wedding(new You()).happyMarry();
    }
}
interface Marry{
    void happyMarry();
}
class You implements Marry{
    public void happyMarrry(){
        System.out.println(" 吃饭。。。");
    }
}
//代理角色
class Wedding implements Marry{
    //真实角色
    private Marry target; 
    Marry(Marry target){
        this.target = target;
    }
     public void happyMarrry(){
        emcee();
        this.target.happyMarry();
        arrange();
    }
    private void emcee(){
        System.out.println("做饭。。");
    }
    private void arrange(){
        System.out.println("洗碗。。。");
    }
}
```

> lambada表达式简化线程

```java
public class Main{
    public static void main(String[] args){
        new Thread(()->{
            for(int i=0;i<100;i++){
                System.out.println("吃饭不如跳舞");
            }
        }).start();
        for(int i=0;i<100;i++){
            System.out.println("吃饭");
        }
    }
}
```

#### 线程状态

```java
线程分为五种种状态：
从新生状态
	(主要)第一种：就绪状态
	(主要)第二种：阻塞状态
	(主要)第三种：运行状态
到死亡状态
```

> 就绪状态

```java
就绪状态分为四种情况：
		1.我们调用start方法时，线程将进入就绪状态.
    	2.当线程解除阻塞状态时将进入就绪状态.
    	3.调用yield方法，让线程中止，让同级线程先执行
    	4.jvm将当前线程（本地线程）切换到其他线程，此线程将进入就绪状态
```

> 阻塞状态

```java
阻塞状态也分为四种情况：
		1.调用sleep方法，让线程睡眠（抱着资源睡觉，别人用不了）.
    	2.wait方法导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法
    	3.jojn方法指定线程等到另一个线程执行完之后再继续执行
    	4.read write .(io方法)
    
    stop方法 强制让线程停止 不推荐使用
```



> 线程的终止

```java
线程的终止方式推荐的俩种：
	1.线程执行完之后自然停止
	2.想办法让不能自然停止的线程自然停止(一般都是无限制的,或没有次数的（while))
```

> 举例

```java
public class Main implements Runnable{
    private boolean termination = true;
    public void run(){
        while(termination){
            System.out.println("吃饭不如跳舞");
        }
    }
    public void stop(){
        System.out.println("停止");
        termination = true;
    }
    public static void main(String args[]){
        for(int i=0;i<19;i++){
            if(i == 10){
                new Main().stop();
            }
        	new Thread(new Main).start();
        }
        for(int i=0;i<10;i++){
            System.out.println("吃饭");
        }
    }
}
```

> 多方代理向同一份资源发起请求

```java
public class Main{
	public static void main(String args[]) {
		Mony mony = new Mony(100,"本金");
		new User(100,mony,"苦逼捞").start();
		new User(100,mony,"她").start();
		try {
			Thread.sleep(200);
			System.out.println("总金额：-->"+mony.getMonySum());
		}
		catch(Exception e) {
			System.out.println("未知的错误");
		}
	}
}
class Mony{
	private static int monySum = 100;
	private String Name;
	Mony(int monySum,String Name){
		this.monySum = monySum;
		this.Name = Name;
	}
	public int getMonySum() {
		return monySum;
	}
	public void setMonySum(int monySum) {
		this.monySum = monySum;
	}
	public String getName() {
		return Name;
	}
	public void setName(String name) {
		Name = name;
	}
}
class User extends Thread{
	private int drawMoney;
	private Mony monySum;
	private int thisMony;
	private String Name;
	public User(int drawMoney,Mony monySum,String Name) {
		this.drawMoney = drawMoney;
		this.monySum = monySum;
		this.Name = Name;
	}
	public void run() {
		while(monySum.getMonySum() - drawMoney >= 0) {
			drawmoney();
		}
	}
	public void drawmoney() {
		monySum.setMonySum(monySum.getMonySum() - drawMoney);
		thisMony += drawMoney;
		System.out.println("当前钱包：   "+thisMony+"\n-->取款人：   "+Name);
	}
}
```

> 同时调用同一份资源

```java
public class Main{
	public static void main(String args[]) {
		ArrayList<String> list = new ArrayList<String>();
		for(int i=0;i<10;i++) {
			new Thread(()->{
				list.add(Thread.currentThread().getName());
			}).start();
		}
		System.out.println("个数："+list.size());
	}
}
```

