## 线程池

```java
诸如 Web 服务器、数据库服务器、文件服务器或邮件服务器之类的许多服务器应用程序都面向处理来自某些远程来源的大量短小的任务。请求以某种方式到达服务器，不管请求如何到达，服务器应用程序中经常出现的情况是：单个任务处理的时间很短而请求的数目却是巨大的。

构建服务器应用程序的一个过于简单的模型应该是：每当一个请求到达就创建一个新线程，然后在新线程中为请求服务。实际上，对于原型开发这种方法工作得很好，但如果试图部署以这种方式运行的服务器应用程序，那么这种方法的严重不足就很明显。每个请求对应一个线程（thread-per-request）方法的不足之一是：为每个请求创建一个新线程的开销很大；为每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多。

除了创建和销毁线程的开销之外，活动的线程也消耗系统资源。在一个 JVM 里创建太多的线程可能会导致系统由于过度消耗内存而用完内存或“切换过度”。为了防止资源不足，服务器应用程序需要一些办法来限制任何给定时刻处理的请求数目。线程池为线程生命周期开销问题和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。其好处是，因为在请求到达时线程已经存在，所以无意中也消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使应用程序响应更快。而且，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。
```

> 线程池的好处

```java
1.执行完原本任务的线程不会死亡，可以重复利用已经执行完的线程，执行其他任务,减少了创建，消亡对象的开销，降低了资源的消耗

2.可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行

3.提供定时执行、定期执行、单线程、并发数控制等功能。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
```

> 创建常用线程池的几种(每个都有自己的特点)依靠Executors中的方法创建线程池

> 一、newCachedThreadPool（无限大线程池）

```java
创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。此线程池不会对线程池大小做限制， 线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
```

> 举例

```java
public static void main(String[] args){
    MyThread1 thread1 = new MyThread1();
    MyThread2 thread2 = new MyThread2();
    ExecutorService threadPool = Executors.newCachedThreadPool();
    threadPool.submit(thread1);
    threadPool.submit(thread2);
    //也可以调用execute提交线程任务  但需要转换一下不能直接放Callable
    threadPool.shutdown();
}
class MyThread1 implements Runnable{
    public void run(){
        System.out.println(Thread.currentThread()+"任务1");
    }
}

class MyThread2 implements Callable<Integer>{
    public Integer call()throws Exception{
        System.out.println(Thread.currentThread()+"任务2");
        return 0;
    }
}
```

> 提示：启动线程池记得关闭哦
>

```java
void shutdown: //建议使用
	启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务.
List<Runnable> shutdownNow:
	尝试停止所有主动执行的任务，停止等待任务的处理，并返回正在等待执行的任务列表，此方法不等待主动执行的任务终止.
```

补充：执行完的线程可以重复利用，无限大小，60秒后清除闲线程.

> 二、newFixedThreadPool（创建固定大小的线程池）

```java
创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。 在任何时候，最多nThreads线程将处于主动处理任务。 如果所有线程处于活动状态时都会提交其他任务，则它们将等待队列中直到线程可用。 如果任何线程由于在关闭之前的执行期间发生故障而终止，则如果需要执行后续任务，则新线程将占用它。 池中的线程将存在，直到它明确地为shutdown.
```

> 举例

```java
public static void main(String[] args){
    MyThread1 thread1 = new MyThread1();
    MyThread2 thread2 = new MyThread2();
    ExecutorService threadPool = Executors.newFixedThreadPool(10);//最大同时执行十个
    threadPool.submit(thread1);
    threadPool.submit(thread2);
    //也可以调用execute提交线程任务  但需要转换一下不能直接放Callable
    threadPool.shutdown();
}
class MyThread1 implements Runnable{
    public void run(){
        System.out.println(Thread.currentThread()+"任务1");
    }
}

class MyThread2 implements Callable<Integer>{
    public Integer call()throws Exception{
        System.out.println(Thread.currentThread()+"任务2");
        return 0;
    }
}
```

补充：有执行完的线程，若当前执行线程数量与最大数量相同才会重复利用，否则不会重复利用.

> 三、newSingleThreadExecutor() 单任务线程池

```java
创建一个使用从无界队列运行的单个工作线程的执行程序。 （请注意，如果这个单个线程由于在关闭之前的执行过程中发生故障而终止，则如果需要执行后续任务，则新的线程将占用它。）任务保证顺序执行，并且不超过一个任务将被激活在任何给定的时间。 与其他等效的"newFixedThreadPool(1)"，返回的执行器保证不被重新配置以使用额外的线程
```

> 举例

```java
public static void main(String[] args){
    MyThread1 thread1 = new MyThread1();
    MyThread2 thread2 = new MyThread2();
    ExecutorService threadPool = Executors.newSingleThreadExecutor();
    threadPool.submit(thread1);
    threadPool.submit(thread2);
    //也可以调用execute提交线程任务 但需要转换一下不能直接放Callable
    threadPool.shutdown();
}
class MyThread1 implements Runnable{
    public void run(){
        System.out.println(Thread.currentThread()+"任务1");
    }
}

class MyThread2 implements Callable<Integer>{
    public Integer call()throws Exception{
        System.out.println(Thread.currentThread()+"任务2");
        return 0;
    }
}
```

补充：重复利用一个线程，不会开辟新线程，新任务等待

> 四、newScheduledThreadPool(int corePoolSize)创建指定线程数的延迟线程连接池

```java
创建一个线程池，可以调度命令在给定的延迟之后运行，或定期执行.
```

> 举例

```java
public static void main(String[] args){
    MyThread1 thread1 = new MyThread1();
    MyThread2 thread2 = new MyThread2();
    ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);//最大十个线程
    //ScheduledExecutorService自己有的延时提交方法 参数：线程对象，定时时间，模式
    threadPool.schedule(thread1,5L,TimeUnit.SECONDS); //我定义的是秒模式，所以是五秒后执行
    threadPool.schedule(thread1,10L,TimeUnit.SECONDS); //十秒
    threadPool.shutdown();
}
class MyThread1 implements Runnable{
    public void run(){
        System.out.println(Thread.currentThread()+"任务1");
    }
}

class MyThread2 implements Callable<Integer>{
    public Integer call()throws Exception{
        System.out.println(Thread.currentThread()+"任务2");
        return 0;
    }
}
```

补充：线程到达最大值才会重复利用线程，支持延时执行线程

> 五、newSingleThreadScheduledExecutor() 单任务延迟线程池

```java
创建一个单线程执行器，可以调度命令在给定的延迟之后运行，或定期执行。 （请注意，如果这个单个线程由于在关闭之前的执行过程中发生故障而终止，则如果需要执行后续任务，则新的线程将占用它。）任务保证顺序执行，并且不超过一个任务将被激活在任何给定的时间。 与其他等效的newScheduledThreadPool(1) newScheduledThreadPool(1) ，返回的执行器保证不被重新配置以使用额外的线程。 
```

> 举例

```java
public static void main(String[] args){
    MyThread1 thread1 = new MyThread1();
    MyThread2 thread2 = new MyThread2();
    ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();
    //ScheduledExecutorService自己有的延时提交方法 参数：线程对象，定时时间，模式
    threadPool.schedule(thread1,5L,TimeUnit.SECONDS); //我定义的是秒模式，所以是五秒后执行
    threadPool.schedule(thread2,10L,TimeUnit.SECONDS); //十秒
    threadPool.shutdown();
}
class MyThread1 implements Runnable{
    public void run(){
        System.out.println(Thread.currentThread()+"任务1");
    }
}

class MyThread2 implements Callable<Integer>{
    public Integer call()throws Exception{
        System.out.println(Thread.currentThread()+"任务2");
        return 0;
    }
}
```

补充：无论提交多少个线程对象都只会执行一个线程，支持延迟执行线程